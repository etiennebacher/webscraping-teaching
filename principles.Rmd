---
title: "Principles of webscraping"
author: "Etienne Bacher"
date: "`r Sys.Date()`"
institute: "LISER"
# format: 
#   revealjs:
#     css: xaringan_themer.css
output:
  xaringan::moon_reader:
    css: xaringan_themer.css
    includes:
      after_body: "ub_theme.html"
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---


class: section

<h1 style="font-size: 40px">The three laws of <span style="text-decoration: line-through;">robotics</span> webscraping</h1>


---

# The three laws of webscraping

.fs-25[
1. Don't be in a hurry

2. Separate the scraping from the formatting

3. Anticipate failure
]


---

# 1. Don't be in hurry

.fs-25[
The scraping shouldn't be too fast for two main reasons:

1. For the website owner: don't flood the server with requests (not all websites you want to scrape are owned by a big company);

2. For you: don't get kicked out / banned.
]


---

# 2. Separate the scraping from the formatting

.center[**Scraping takes time (cf previous slide).**]

.h-1em[]

You should minimize the risk of crashing and losing your progress, which means minimizing the operations at each iteration.

--

We have:
1. lots of storing space on our laptops
2. not a lot of time

.color2[*Save the raw HTML in external files first. You will be able to clean it later (and offline).*]


---

# 3. Anticipate failure

Minimizing the risk of failures doesn't mean that there won't be any failures.

.h-1em[]

Your code should be resilient to these failures and keep running.

.h-1em[]

In R, this can be done with `try()` and `tryCatch()`.

---

# 3. Anticipate failure

Let's create a dummy function that takes `x` and:
* returns `x*2` if `x >= 0`
* errors if `x < 0`
```{r error = TRUE}
dummy_fun <- function(x) {
  if (x < 0) stop("x is not big enough")
  return(x*2)
}
dummy_fun(-1)
dummy_fun(1)
```

---

# 3. Anticipate failure

What happens if we loop through this function from -1 to 1? 

```{r error = TRUE}
for (i in -1:1) {
  print(i)
  dummy_fun(i)
}
```

--

.h-1em[]

Because the function doesn't handle errors, .color2[*the error stops the whole loop*] (we never run `dummy_fun(0)` and `dummy_fun(1)`).

---

# 3. Anticipate failure

```{r}
x <- try(dummy_fun(-1), silent = TRUE)
class(x)
```

--

```{r error = TRUE}
for (i in -1:1) {
  print(i)
  x <- try(dummy_fun(i), silent = TRUE) #<<
  
  if (inherits(x, "try-error")) {
    NULL
  } else {
    x
  }
}
```


---

# 3. Anticipate failure

```{r}
x <- tryCatch(
  dummy_fun(-1),
  error = function(e) {
    print("This is a custom error message")
    print(paste("Original error:", e))
  }
)
class(x)
```



